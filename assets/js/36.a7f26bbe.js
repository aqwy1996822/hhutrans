(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{906:function(t,a,r){"use strict";r.r(a);var s=r(8),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"定机位"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定机位"}},[t._v("#")]),t._v(" 定机位")]),t._v(" "),r("p",[t._v("根据3DMAX中模拟和现场测试，确定机位，要求两台相机，纵向能拍到全程2M高的画面，横向能覆盖3.5M的测试范围。")]),t._v(" "),r("h2",{attrs:{id:"单相机误差试验"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单相机误差试验"}},[t._v("#")]),t._v(" 单相机误差试验")]),t._v(" "),r("p",[t._v("单个相机在选定的机位方案中，对负责测距区域的点进行测距，计算其误差，确保总误差低于1CM。")]),t._v(" "),r("h2",{attrs:{id:"交互界面开发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#交互界面开发"}},[t._v("#")]),t._v(" 交互界面开发")]),t._v(" "),r("p",[t._v("基于C++开发具备参数调整、测试区域选定，测试实时预览，结果显示的交互界面。")]),t._v(" "),r("h2",{attrs:{id:"起跳线识别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#起跳线识别"}},[t._v("#")]),t._v(" 起跳线识别")]),t._v(" "),r("p",[t._v("比较简单，确定起跳线的线形颜色，要求框选并识别。")]),t._v(" "),r("h2",{attrs:{id:"地面平面识别与起跳点垂线在地面上投影的向量计算"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#地面平面识别与起跳点垂线在地面上投影的向量计算"}},[t._v("#")]),t._v(" 地面平面识别与起跳点垂线在地面上投影的向量计算")]),t._v(" "),r("p",[t._v("检测起跳线只能知道对应法平面，需要检测地面平面，再计算与该法平面的交线，得到起跳方向在地上投影的向量。")]),t._v(" "),r("h2",{attrs:{id:"两相机在三脚架上的固定方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两相机在三脚架上的固定方案"}},[t._v("#")]),t._v(" 两相机在三脚架上的固定方案")]),t._v(" "),r("p",[t._v("要求精准得到两相机间的位移，旋转关系。")]),t._v(" "),r("h2",{attrs:{id:"起跳和落地姿态检测算法的重写"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#起跳和落地姿态检测算法的重写"}},[t._v("#")]),t._v(" 起跳和落地姿态检测算法的重写")]),t._v(" "),r("p",[t._v("过去算法面向侧面，根据骨架确定重心偏向与速度计算，根据经验设置阈值。"),r("br"),t._v("\n现在需要针对侧前和侧后方设计算法。")]),t._v(" "),r("h2",{attrs:{id:"所有算法向c-的移植"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#所有算法向c-的移植"}},[t._v("#")]),t._v(" 所有算法向c++的移植")]),t._v(" "),r("p",[t._v("难点在于tensorflow和pytorch模型向c++的迁移，其中pytorch无c++官方库，需要找到模型转化的办法。")])])}),[],!1,null,null,null);a.default=v.exports}}]);